<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Podcast Chunk Master</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        .animate-fadeIn { animation: fadeIn 0.3s ease-out; }
        .animate-popIn { animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        /* å†ç”Ÿä¸­ã®ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        .progress-bar { transition: width 0.1s linear; }
        
        /* ã‚«ã‚¹ã‚¿ãƒ ãƒ¬ãƒ³ã‚¸ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #22c55e;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 2px;
        }
        input[type=range]:focus {
            outline: none;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ã‚¢ã‚¤ã‚³ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ ---
        const IconBase = ({ children, className }) => <span className={`inline-flex items-center justify-center ${className}`}>{children}</span>;
        const Play = ({ className }) => <IconBase className={className}>â–¶</IconBase>;
        const Pause = ({ className }) => <IconBase className={className}>â¸</IconBase>;
        const Settings = ({ className }) => <IconBase className={className}>âš™ï¸</IconBase>;
        const ChevronRight = ({ className }) => <IconBase className={className}>â€º</IconBase>;
        const ChevronLeft = ({ className }) => <IconBase className={className}>â€¹</IconBase>;
        const Upload = ({ className }) => <IconBase className={className}>ğŸ“¤</IconBase>;
        const FileText = ({ className }) => <IconBase className={className}>ğŸ“„</IconBase>;
        const Music = ({ className }) => <IconBase className={className}>ğŸµ</IconBase>;
        const X = ({ className }) => <IconBase className={className}>âœ•</IconBase>;
        const Save = ({ className }) => <IconBase className={className}>ğŸ’¾</IconBase>;
        const Check = ({ className }) => <IconBase className={className}>âœ“</IconBase>;
        const Eye = ({ className }) => <IconBase className={className}>ğŸ‘ï¸</IconBase>;
        const EyeOff = ({ className }) => <IconBase className={className}>ğŸ™ˆ</IconBase>;
        const Clock = ({ className }) => <IconBase className={className}>ğŸ•’</IconBase>;
        const Refresh = ({ className }) => <IconBase className={className}>ğŸ”„</IconBase>;

        // --- åˆæœŸãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ (ãƒ‡ãƒ¢ç”¨) ---
        const DEMO_CSV_CONTENT = `ID|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è‹±æ–‡|æ—¥æœ¬èªè¨³|ãƒãƒ£ãƒ³ã‚¯1|ãƒãƒ£ãƒ³ã‚¯2|ãƒãƒ£ãƒ³ã‚¯3|ãƒãƒ£ãƒ³ã‚¯4
1|0|A new cold war has broken out between the US and China over artificial intelligence.|äººå·¥çŸ¥èƒ½ã‚’å·¡ã£ã¦ã€ã‚¢ãƒ¡ãƒªã‚«ã¨ä¸­å›½ã®é–“ã§æ–°ã—ã„å†·æˆ¦ãŒå‹ƒç™ºã—ã¾ã—ãŸã€‚|A new cold war has broken out^Subject + Verb^core^æ–°ã—ã„å†·æˆ¦ãŒå‹ƒç™ºã—ãŸ|between the US and China^Prep Phrase^modifier^ã‚¢ãƒ¡ãƒªã‚«ã¨ä¸­å›½ã®é–“ã§|over artificial intelligence.^Prep Phrase^modifier^äººå·¥çŸ¥èƒ½ã‚’å·¡ã£ã¦
2|10|The US and China are locked in a competition that bears some really striking similarities to the tech races between the US and Soviet Union.|ã‚¢ãƒ¡ãƒªã‚«ã¨ä¸­å›½ã¯ã€æŠ€è¡“ç«¶äº‰ã¨é¡ä¼¼ç‚¹ã‚’æŒã¤ç«¶äº‰ã®ä¸­ã§è† ç€çŠ¶æ…‹ã«ã‚ã‚Šã¾ã™ã€‚|The US and China are locked^S+V^core^ç±³ä¸­ã¯è† ç€çŠ¶æ…‹ã«ã‚ã‚‹|in a competition^Prep Phrase^modifier^ã‚ã‚‹ç«¶äº‰ã®ä¸­ã§|that bears^Relative Clause^connector^ï¼ˆãã®ç«¶äº‰ã¯ï¼‰æŒã£ã¦ã„ã‚‹|some really striking similarities^Object^core^ã„ãã¤ã‹ã®éå¸¸ã«éš›ç«‹ã£ãŸé¡ä¼¼ç‚¹ã‚’
3|25|Josh says that history is repeating itself with AI.|ã‚¸ãƒ§ã‚·ãƒ¥ã¯ã€AIã«ãŠã„ã¦æ­´å²ã¯ç¹°ã‚Šè¿”ã—ã¦ã„ã‚‹ã¨è¨€ã„ã¾ã™ã€‚|Josh says^S+V^core^ã‚¸ãƒ§ã‚·ãƒ¥ã¯è¨€ã†|that history is repeating itself^Noun Clause^core^æ­´å²ã¯ç¹°ã‚Šè¿”ã—ã¦ã„ã‚‹ã¨|with AI.^Prep Phrase^modifier^AIã«ãŠã„ã¦
4|35|Whichever country manages to run away with a lead stands to reap huge advantages in economic and military power.|ãƒªãƒ¼ãƒ‰ã‚’å¥ªã„å»ã‚‹ã“ã¨ã«æˆåŠŸã—ãŸå›½ã¯ã©ã“ã§ã‚ã‚Œã€è«å¤§ãªåˆ©ç›Šã‚’å¾—ã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ã€‚|Whichever country manages^Subject Clause^core^ä½•ã¨ã‹ã—ã‚ˆã†ã¨ã™ã‚‹å›½ã¯ã©ã“ã§ã‚‚|to run away with a lead^Infinitive^modifier^ãƒªãƒ¼ãƒ‰ã‚’å¥ªã„å»ã‚‹ï¼ˆç‹¬èµ°ã™ã‚‹ï¼‰|stands to reap^Verb Phrase^core^ï¼ˆåˆ©ç›Šã‚’ï¼‰å¾—ã‚‹ç«‹å ´ã«ã‚ã‚‹|huge advantages^Object^core^è«å¤§ãªåˆ©ç›Šã‚’`;

        // è‰²åˆ†ã‘è¨­å®š
        const TYPE_COLORS = {
            core: "bg-red-100 text-red-800 border-red-200",
            modifier: "bg-green-100 text-green-800 border-green-200",
            connector: "bg-blue-100 text-blue-800 border-blue-200"
        };

        function PodcastChunkMaster() {
            // --- State ---
            const [sentences, setSentences] = useState([]);
            const [currentIndex, setCurrentIndex] = useState(0);
            const [mode, setMode] = useState('study'); 
            const [showMeaning, setShowMeaning] = useState(false);
            
            // Podcast Audio State
            const [podcastAudioSrc, setPodcastAudioSrc] = useState(null);
            const [isAudioPlaying, setIsAudioPlaying] = useState(false);
            const [audioCurrentTime, setAudioCurrentTime] = useState(0);
            const [audioDuration, setAudioDuration] = useState(0); // ç·æ™‚é–“ã‚’è¿½åŠ 
            const audioPlayerRef = useRef(null);
            
            // ã‚·ãƒ¼ã‚¯æ“ä½œä¸­ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹Refï¼ˆuseEffectã®ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
            const isSeekingRef = useRef(false);
            
            // Episode Management
            const [fileList, setFileList] = useState([]); 
            const [selectedFileName, setSelectedFileName] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [loadError, setLoadError] = useState(null);

            // UI State (Settings)
            const [csvInput, setCsvInput] = useState(DEMO_CSV_CONTENT);

            const currentSentence = sentences[currentIndex] || {};
            const nextSentence = sentences[currentIndex + 1];

            // --- Effects ---
            
            // åˆæœŸãƒ­ãƒ¼ãƒ‰: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¸€è¦§ã‚’å–å¾—ã—ã«ã„ã
            useEffect(() => {
                fetchDirectoryListing();
            }, []);

            // ã‚»ãƒ³ãƒ†ãƒ³ã‚¹åˆ‡ã‚Šæ›¿ãˆæ™‚ã®å‡¦ç†ï¼ˆè¡¨ç¤ºã®æ›´æ–°ã¨ã€å¿…è¦ã«å¿œã˜ãŸã‚·ãƒ¼ã‚¯ï¼‰
            useEffect(() => {
                setShowMeaning(false); // ãƒšãƒ¼ã‚¸ã‚ãã‚Šã§è¨³ã‚’éš ã™
                
                // ã‚·ãƒ¼ã‚¯æ“ä½œä¸­ä»¥å¤–ã§ã€éŸ³å£°ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆ
                if (!isSeekingRef.current && podcastAudioSrc && audioPlayerRef.current) {
                    const startTime = currentSentence.timestamp || 0;
                    const currentTime = audioPlayerRef.current.currentTime;
                    
                    // ã€Œè‡ªå‹•å†ç”Ÿã§è‡ªç„¶ã«æ¬¡ã®æ–‡ã¸ç§»ã£ãŸã€ã®ã‹ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒœã‚¿ãƒ³ã§é£›ã°ã—ãŸã€ã®ã‹ã‚’åˆ¤å®š
                    // ç¾åœ¨ã®æ™‚é–“ãŒã€æ–°ã—ã„æ–‡ã®é–‹å§‹æ™‚é–“ã¨å¤§ãããšã‚Œã¦ã„ã‚‹å ´åˆã®ã¿ã‚·ãƒ¼ã‚¯ã™ã‚‹
                    // (è‡ªç„¶ã«å†ç”Ÿã•ã‚Œã¦ã„ã‚‹å ´åˆã€currentTimeã¯startTimeã‚ˆã‚Šã‚ãšã‹ã«å¤§ãã„ã¯ãš)
                    const timeDiff = Math.abs(currentTime - startTime);
                    
                    if (timeDiff > 1.5) { // 1.5ç§’ä»¥ä¸Šã®ã‚ºãƒ¬ãŒã‚ã‚‹å ´åˆã¯ã€ãƒœã‚¿ãƒ³æ“ä½œã«ã‚ˆã‚‹ã‚¸ãƒ£ãƒ³ãƒ—ã¨ã¿ãªã—ã¦é ­å‡ºã—
                        audioPlayerRef.current.currentTime = startTime;
                        setAudioCurrentTime(startTime);
                    }
                    
                    // éŸ³å£°ãŒæ­¢ã¾ã£ã¦ã„ãŸã‚‰å†ç”Ÿã™ã‚‹ï¼ˆPlayãƒœã‚¿ãƒ³ã§é£›ã°ã—ãŸå ´åˆãªã©ï¼‰
                    if (isAudioPlaying && audioPlayerRef.current.paused) {
                        playPodcast();
                    }
                }
            }, [currentIndex]); 

            // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ç›£è¦–ï¼ˆå†ç”Ÿä½ç½®ã«å¿œã˜ã¦currentIndexã‚’è‡ªå‹•æ›´æ–°ï¼‰
            useEffect(() => {
                if (!isAudioPlaying || !podcastAudioSrc) return;

                const checkTime = () => {
                    const player = audioPlayerRef.current;
                    if (!player) return;

                    const time = player.currentTime;
                    setAudioCurrentTime(time);

                    if (!isSeekingRef.current) {
                        // ç¾åœ¨ã®æ™‚é–“ã«å¯¾å¿œã™ã‚‹ã‚»ãƒ³ãƒ†ãƒ³ã‚¹ã‚’æ¢ã™
                        let newIndex = -1;
                        for (let i = 0; i < sentences.length; i++) {
                            // ç¾åœ¨æ™‚é–“ã‚ˆã‚Šé–‹å§‹æ™‚é–“ãŒå‰ã®ã‚‚ã®ã®ã†ã¡ã€ä¸€ç•ªå¾Œã‚ã®ã‚‚ã®
                            if (sentences[i].timestamp <= time) {
                                newIndex = i;
                            } else {
                                // æ™‚é–“ã‚’è¶…ãˆãŸã‚‰çµ‚äº†
                                break;
                            }
                        }
                        
                        // è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯æœ€åˆã¸
                        if (newIndex === -1) newIndex = 0;

                        // ç¾åœ¨ã®è¡¨ç¤ºã¨é•ã†å ´åˆã®ã¿æ›´æ–°ï¼ˆè‡ªå‹•ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰
                        if (newIndex !== currentIndex) {
                            setCurrentIndex(newIndex);
                        }
                    }
                };

                const interval = setInterval(checkTime, 100);
                return () => clearInterval(interval);
            }, [isAudioPlaying, sentences, currentIndex, podcastAudioSrc]);

            // --- Functions ---
            
            // æ™‚é–“ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼ (åˆ†:ç§’)
            const formatTime = (seconds) => {
                if (!seconds || isNaN(seconds)) return "0:00";
                const m = Math.floor(seconds / 60);
                const s = Math.floor(seconds % 60).toString().padStart(2, '0');
                return `${m}:${s}`;
            };

            // ã‚·ãƒ¼ã‚¯ãƒãƒ¼æ“ä½œãƒãƒ³ãƒ‰ãƒ©
            const handleSeek = (e) => {
                const newTime = parseFloat(e.target.value);
                setAudioCurrentTime(newTime);
                
                if (audioPlayerRef.current) {
                    isSeekingRef.current = true; // ã‚·ãƒ¼ã‚¯æ“ä½œé–‹å§‹ãƒ•ãƒ©ã‚°
                    audioPlayerRef.current.currentTime = newTime;
                    
                    // ç¾åœ¨ã®æ™‚é–“ã«å¯¾å¿œã™ã‚‹ã‚»ãƒ³ãƒ†ãƒ³ã‚¹ã‚’æ¢ã—ã¦å³åº§ã«è¡¨ç¤ºåˆ‡æ›¿
                    const newIndex = sentences.reduce((foundIdx, s, idx) => {
                        return (s.timestamp <= newTime) ? idx : foundIdx;
                    }, 0);

                    if (newIndex !== currentIndex) {
                        setCurrentIndex(newIndex);
                    }

                    // å°‘ã—çµŒã£ãŸã‚‰ã‚·ãƒ¼ã‚¯ãƒ•ãƒ©ã‚°ã‚’ä¸‹ã‚ã™
                    setTimeout(() => {
                        isSeekingRef.current = false;
                    }, 500);
                }
            };

            // ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¸€è¦§å–å¾—
            const fetchDirectoryListing = async () => {
                setIsLoading(true);
                setLoadError(null);
                try {
                    const res = await fetch('podcast/');
                    if (!res.ok) throw new Error(`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªä¸€è¦§ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ (${res.status})`);
                    
                    const text = await res.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(text, 'text/html');
                    const links = Array.from(doc.querySelectorAll('a'));
                    
                    const mp3Files = links
                        .map(link => link.getAttribute('href'))
                        .filter(href => href && href.toLowerCase().endsWith('.mp3'))
                        .map(href => {
                            const decoded = decodeURIComponent(href);
                            return decoded.split('/').pop(); 
                        });

                    const uniqueFiles = [...new Set(mp3Files)].sort();

                    if (uniqueFiles.length > 0) {
                        setFileList(uniqueFiles);
                        loadFile(uniqueFiles[0]);
                    } else {
                        console.warn("No mp3 files found.");
                        setFileList([]);
                        loadFile('demo'); 
                    }
                } catch (err) {
                    console.error("Auto-discovery failed:", err);
                    setLoadError("ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ã®è‡ªå‹•å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚µãƒ¼ãƒãƒ¼ã®è¨­å®š(Auto Index)ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚ãƒ‡ãƒ¢ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚");
                    loadFile('demo');
                } finally {
                    setIsLoading(false);
                }
            };

            // ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å‡¦ç†
            const loadFile = async (fileName) => {
                setIsLoading(true);
                setLoadError(null);
                setSelectedFileName(fileName);
                
                if (fileName === 'demo') {
                    parseCSV(DEMO_CSV_CONTENT);
                    setPodcastAudioSrc(null);
                    setIsLoading(false);
                    return;
                }

                const mp3Path = `podcast/${fileName}`;
                const csvPath = `podcast/${fileName.replace(/\.mp3$/i, '.csv')}`;

                try {
                    const res = await fetch(csvPath);
                    if (!res.ok) {
                         if(res.status === 404) {
                             throw new Error(`CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${csvPath}\nMP3ã¨åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«åã§ã€æ‹¡å¼µå­ã‚’.csvã«ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”¨æ„ã—ã¦ãã ã•ã„ã€‚`);
                         }
                         throw new Error(`CSVèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼ (${res.status}): ${csvPath}`);
                    }
                    const text = await res.text();
                    parseCSV(text);
                    setPodcastAudioSrc(mp3Path);
                } catch (err) {
                    console.error(err);
                    setLoadError(err.message);
                    setPodcastAudioSrc(mp3Path); // éŸ³å£°ã ã‘ã‚»ãƒƒãƒˆ
                    
                    setSentences([{
                        id: 0,
                        timestamp: 0,
                        text: "No CSV Data Available",
                        translation: "CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚éŸ³å£°ã®ã¿å†ç”Ÿå¯èƒ½ã§ã™ã€‚",
                        chunks: [{ text: "CSV File Not Found", label: "Error", type: "core", japanese: "CSVãƒ•ã‚¡ã‚¤ãƒ«ãªã—" }]
                    }]);
                    setCurrentIndex(0);
                } finally {
                    setIsLoading(false);
                }
            };

            const parseCSV = (text) => {
                try {
                    const lines = text.trim().split('\n');
                    const newSentences = lines.map((line, index) => {
                        const cleanLine = line.trim().replace(/^\uFEFF/, '');
                        if (index === 0 && (cleanLine.toLowerCase().startsWith('id') || cleanLine.includes('è‹±æ–‡'))) return null;
                        if (!cleanLine) return null;

                        const parts = cleanLine.split('|').map(p => p.trim());
                        if (parts.length < 4) return null;

                        let idVal = parseInt(parts[0], 10);
                        if (isNaN(idVal)) idVal = index + 1;

                        const timestamp = parseFloat(parts[1]) || 0;
                        const sentenceText = parts[2];
                        const translation = parts[3];
                        
                        const chunkRawData = parts.slice(4);
                        const chunks = chunkRawData.map(chunkStr => {
                            if (!chunkStr) return null;
                            const [cText, cLabel, cType, cJp] = chunkStr.split('^').map(s => s?.trim());
                            return {
                                text: cText || "",
                                label: cLabel || "",
                                type: (cType === 'core' || cType === 'modifier' || cType === 'connector') ? cType : 'core',
                                japanese: cJp || ""
                            };
                        }).filter(c => c && c.text);

                        return { id: idVal, timestamp, text: sentenceText, translation, chunks };
                    }).filter(Boolean);

                    if (newSentences.length === 0) throw new Error("ãƒ‡ãƒ¼ã‚¿ãŒç©ºã‹ã€å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚");

                    setSentences(newSentences);
                    setCurrentIndex(0);
                    setCsvInput(text);
                } catch (e) {
                    setLoadError("CSVè§£æã‚¨ãƒ©ãƒ¼: " + e.message);
                }
            };

            const handlePodcastUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    if (podcastAudioSrc) URL.revokeObjectURL(podcastAudioSrc);
                    const url = URL.createObjectURL(file);
                    setPodcastAudioSrc(url);
                }
            };

            const playPodcast = () => {
                if (audioPlayerRef.current && podcastAudioSrc) {
                    audioPlayerRef.current.play().then(() => {
                        setIsAudioPlaying(true);
                    }).catch(e => {
                        console.error("Audio error:", e);
                        alert("éŸ³å£°ã‚’å†ç”Ÿã§ãã¾ã›ã‚“ã€‚");
                    });
                } else {
                    if(!podcastAudioSrc) alert("éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                }
            };

            const pausePodcast = () => {
                if (audioPlayerRef.current) {
                    audioPlayerRef.current.pause();
                    setIsAudioPlaying(false);
                }
            };

            if (sentences.length === 0 && !isLoading) return <div className="p-10 text-center">Loading...</div>;

            return (
                <div className="min-h-screen bg-gray-50 text-gray-800 font-sans pb-20">
                    <audio 
                        ref={audioPlayerRef} 
                        src={podcastAudioSrc} 
                        onEnded={()=> setIsAudioPlaying(false)} 
                        onError={() => setIsAudioPlaying(false)}
                        onLoadedMetadata={(e) => setAudioDuration(e.target.duration)}
                    />

                    <header className="bg-slate-900 text-white p-4 shadow-md sticky top-0 z-30">
                        <div className="max-w-md mx-auto">
                            <div className="flex justify-between items-center mb-2">
                                <h1 className="text-lg font-bold flex items-center gap-2">
                                    <Music className="w-5 h-5 text-green-400" />
                                    Podcast Chunk Master
                                </h1>
                                <button onClick={()=> setMode(mode === 'settings' ? 'study' : 'settings')} className={`p-2 rounded-full transition ${mode === 'settings' ? 'bg-slate-700' : 'hover:bg-slate-800'}`}>
                                    {mode === 'settings' ? <X className="w-5 h-5" /> : <Settings className="w-5 h-5" />}
                                </button>
                            </div>

                            {/* ã‚¨ãƒ”ã‚½ãƒ¼ãƒ‰é¸æŠãƒ¡ãƒ‹ãƒ¥ãƒ¼ */}
                            <div className="flex gap-2 items-center">
                                <select 
                                    className="flex-1 bg-slate-800 text-sm rounded px-2 py-1 border border-slate-700 focus:outline-none focus:border-green-500"
                                    value={selectedFileName}
                                    onChange={(e) => loadFile(e.target.value)}
                                >
                                    {fileList.length === 0 && <option value="demo">-- Demo Data (No files found) --</option>}
                                    {fileList.map((fileName, idx) => (
                                        <option key={idx} value={fileName}>{fileName}</option>
                                    ))}
                                </select>
                                <button onClick={fetchDirectoryListing} className="p-1 bg-slate-800 rounded hover:bg-slate-700 text-gray-400" title="ãƒªã‚¹ãƒˆæ›´æ–°">
                                    <Refresh className="w-4 h-4" />
                                </button>
                            </div>
                            
                            {/* ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */}
                            {loadError && (
                                <div className="mt-2 text-xs text-red-200 bg-red-900/80 p-2 rounded border border-red-700 whitespace-pre-wrap">
                                    âš ï¸ {loadError}
                                </div>
                            )}
                        </div>
                    </header>

                    <main className="max-w-md mx-auto p-4 space-y-6">
                        
                        {/* ãƒ¡ã‚¤ãƒ³ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ */}
                        {mode !== 'settings' && (
                            <div className="bg-white p-4 rounded-2xl shadow-sm border border-gray-200 sticky top-[100px] z-20">
                                <div className="flex justify-between items-end mb-2">
                                    <div className="text-xs font-bold text-gray-500 flex items-center gap-1">
                                        <Clock className="w-3 h-3" />
                                        <span>{formatTime(audioCurrentTime)}</span>
                                        <span className="text-gray-300">/</span>
                                        <span>{formatTime(audioDuration)}</span>
                                    </div>
                                    <div className="text-xs font-mono text-indigo-600 bg-indigo-50 px-2 py-0.5 rounded">
                                        ID: {currentSentence.id}
                                    </div>
                                </div>
                                
                                {/* å…¨ä½“ã‚·ãƒ¼ã‚¯ãƒãƒ¼ */}
                                <div className="mb-4 flex items-center">
                                    <input 
                                        type="range" 
                                        min="0" 
                                        max={audioDuration || 100} 
                                        step="0.1"
                                        value={audioCurrentTime} 
                                        onChange={handleSeek}
                                        className="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-green-500"
                                    />
                                </div>

                                <div className="flex items-center gap-2">
                                    <button onClick={() => setCurrentIndex(prev => Math.max(0, prev - 1))} disabled={currentIndex === 0} className="p-3 bg-gray-100 rounded-full hover:bg-gray-200 disabled:opacity-30 transition"><ChevronLeft className="w-5 h-5 text-gray-600" /></button>
                                    
                                    <button onClick={isAudioPlaying ? pausePodcast : playPodcast} className={`flex-1 py-3 rounded-xl flex items-center justify-center gap-2 font-bold shadow-md transition ${isAudioPlaying ? 'bg-green-100 text-green-700 border border-green-200' : 'bg-slate-800 text-white hover:bg-slate-700'}`}>
                                        {isAudioPlaying ? <Pause className="w-5 h-5" /> : <Play className="w-5 h-5" />}
                                        {isAudioPlaying ? "Pause" : "Play"}
                                    </button>

                                    <button onClick={() => setCurrentIndex(prev => Math.min(sentences.length - 1, prev + 1))} disabled={currentIndex === sentences.length - 1} className="p-3 bg-gray-100 rounded-full hover:bg-gray-200 disabled:opacity-30 transition"><ChevronRight className="w-5 h-5 text-gray-600" /></button>
                                </div>
                            </div>
                        )}

                        {mode === 'settings' ? (
                            <div className="space-y-6 animate-fadeIn">
                                {/* è¨­å®š: CSVå…¥åŠ› */}
                                <div className="bg-white p-6 rounded-2xl shadow-sm border border-gray-200">
                                    <h2 className="text-lg font-bold mb-4 flex items-center gap-2"><FileText className="w-5 h-5 text-indigo-600" />ã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿ç·¨é›†</h2>
                                    <div className="mb-4">
                                        <label className="block text-sm font-bold text-gray-700 mb-2">CSVãƒ‡ãƒ¼ã‚¿ç›´æ¥ç·¨é›†</label>
                                        <textarea 
                                            className="w-full h-32 p-3 text-xs border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none font-mono leading-relaxed" 
                                            value={csvInput} 
                                            onChange={(e)=> setCsvInput(e.target.value)} 
                                        />
                                        <button onClick={() => parseCSV(csvInput)} className="mt-3 w-full bg-indigo-600 text-white py-2 rounded-lg font-bold hover:bg-indigo-700 transition flex items-center justify-center gap-2"><Save className="w-4 h-4" />ãƒ‡ãƒ¼ã‚¿ã‚’åæ˜ </button>
                                    </div>
                                </div>

                                {/* è¨­å®š: éŸ³å£°ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ */}
                                <div className="bg-white p-6 rounded-2xl shadow-sm border border-gray-200">
                                    <h2 className="text-lg font-bold mb-4 flex items-center gap-2"><Music className="w-5 h-5 text-pink-500" />æ‰‹å‹•ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿</h2>
                                    <p className="text-xs text-gray-500 mb-4">podcastãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ã®è‡ªå‹•èª­ã¿è¾¼ã¿ãŒã†ã¾ãã„ã‹ãªã„å ´åˆã¯ã€ã“ã¡ã‚‰ã‹ã‚‰MP3ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚</p>
                                    
                                    <label className="block w-full cursor-pointer bg-pink-50 hover:bg-pink-100 text-pink-700 py-6 px-4 rounded-xl border-2 border-dashed border-pink-200 text-center transition">
                                        <span className="flex flex-col items-center justify-center gap-2">
                                            <Upload className="w-6 h-6" /> 
                                            <span className="font-bold">éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</span>
                                        </span>
                                        <input type="file" accept="audio/*" className="hidden" onChange={handlePodcastUpload} />
                                    </label>
                                    {podcastAudioSrc && <div className="mt-3 text-xs text-green-600 font-bold text-center flex items-center justify-center gap-1"><Check className="w-3 h-3"/> éŸ³å£°æº–å‚™OK</div>}
                                </div>
                            </div>
                        ) : (
                            <>
                                <div className="space-y-6 animate-fadeIn">
                                    <div className="bg-white p-6 rounded-2xl shadow-sm border border-gray-100">
                                        <div className="flex flex-wrap gap-2 mb-4 leading-relaxed">
                                            {currentSentence.chunks && currentSentence.chunks.map((chunk, idx) => (
                                                <div key={idx} className="group relative cursor-pointer">
                                                    <span className={`inline-block px-2 py-1 rounded border-b-2 text-lg font-medium transition-all hover:opacity-80 ${TYPE_COLORS[chunk.type] || "bg-gray-100"}`}>{chunk.text}</span>
                                                    <div className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 w-max px-2 py-1 bg-gray-800 text-white text-xs rounded opacity-0 group-hover:opacity-100 transition pointer-events-none z-20 shadow-lg"><p className="font-bold text-center">{chunk.label}</p><p className="text-gray-300 text-center">{chunk.japanese}</p></div>
                                                </div>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Meaning ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ */}
                                    <div className="bg-indigo-50 p-4 rounded-xl border border-indigo-100 text-center">
                                        {!showMeaning ? (
                                            <button 
                                                onClick={() => setShowMeaning(true)} 
                                                className="w-full py-3 bg-white text-indigo-600 font-bold rounded-lg shadow-sm border border-indigo-200 hover:bg-indigo-50 transition flex items-center justify-center gap-2"
                                            >
                                                <Eye className="w-5 h-5" /> æ—¥æœ¬èªè¨³ã‚’è¡¨ç¤ºã™ã‚‹
                                            </button>
                                        ) : (
                                            <div className="animate-fadeIn relative">
                                                <p className="text-gray-800 font-medium text-lg leading-relaxed py-2">
                                                    {currentSentence.translation}
                                                </p>
                                                <button 
                                                    onClick={() => setShowMeaning(false)} 
                                                    className="mt-2 text-xs text-indigo-400 hover:text-indigo-600 flex items-center justify-center gap-1 mx-auto"
                                                >
                                                    <EyeOff className="w-3 h-3" /> éš ã™
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </>
                        )}
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PodcastChunkMaster />);
    </script>
</body>
</html>